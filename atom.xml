<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>但行好事，莫问前程</title>
  
  <subtitle>CV工程师，了解面向Google编程的基本原理，有三年使用Google经验，在通往程序员的道路上艰难的爬行着。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-03T01:30:27.668Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fengbo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/3017/08/16/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/3017/08/16/一些知识点的链接/</id>
    <published>3017-08-16T14:01:40.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="后端架构师技术图谱-正则表达式入门-NIO教程"><a href="#后端架构师技术图谱-正则表达式入门-NIO教程" class="headerlink" title="后端架构师技术图谱 | 正则表达式入门 | NIO教程"></a><a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">后端架构师技术图谱</a> | <a href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html" target="_blank" rel="noopener">正则表达式入门</a> | <a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">NIO教程</a></h3><h3 id="大数据简介-Spark中文文档-Flink中文文档-Spring-MVC中文文档-Vert-x中文文档"><a href="#大数据简介-Spark中文文档-Flink中文文档-Spring-MVC中文文档-Vert-x中文文档" class="headerlink" title="大数据简介 | Spark中文文档 | Flink中文文档 | Spring MVC中文文档 | Vert.x中文文档"></a><a href="https://www.zhihu.com/question/27974418/answer/38965760" target="_blank" rel="noopener">大数据简介</a> | <a href="http://spark.apachecn.org/docs/cn/2.2.0/" target="_blank" rel="noopener">Spark中文文档</a> | <a href="http://flink.iteblog.com/" target="_blank" rel="noopener">Flink中文文档</a> | <a href="https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation" target="_blank" rel="noopener">Spring MVC中文文档</a> | <a href="https://vertxchina.github.io/vertx-translation-chinese/" target="_blank" rel="noopener">Vert.x中文文档</a></h3><h3 id="Docker入门-Docsify"><a href="#Docker入门-Docsify" class="headerlink" title="Docker入门 | Docsify"></a><a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker入门</a> | <a href="https://docsify.js.org/#/zh-cn/" target="_blank" rel="noopener">Docsify</a></h3><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码</a></h3><p><a href="https://www.zhihu.com/question/19796490" target="_blank" rel="noopener"><img src="/img/知识体系.svg"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;后端架构师技术图谱-正则表达式入门-NIO教程&quot;&gt;&lt;a href=&quot;#后端架构师技术图谱-正则表达式入门-NIO教程&quot; class=&quot;headerlink&quot; title=&quot;后端架构师技术图谱 | 正则表达式入门 | NIO教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>加密算法基础</title>
    <link href="http://yoursite.com/2020/11/14/%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/14/基础之加密算法/</id>
    <published>2020-11-14T11:38:05.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础加密技术"><a href="#基础加密技术" class="headerlink" title="基础加密技术"></a>基础加密技术</h3><ul><li>对称密码(AES)：加密和解密使用同一把密匙的加密算法。<ul><li>ECB模式：直接切割明文然后加密成密文，简单、快速、不安全。</li><li>CBC模式：TLS/SSL使用该模式，推荐使用。</li><li>CFB模式、OFB模式和CTR模式都是安全的模式，不太能分清优缺点。</li></ul></li><li>公钥密码(RSA)：使用公匙加密，私匙解密的加密算法。<a id="more"></a></li></ul><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><ul><li>单向散列函数：通过计算数据的Hash值来保证文件或数据的完整性。具体算法包括MD5和SHA-3等。</li><li>消息认证码(HMAC)：一种与密匙相关联的单向散列函数。不仅可以保证数据的完整性，确认消息是否被篡改。而且可以确认消息是否来自所期待的对象。<ul><li>消息认证码的输入包括任意长度的消息和一个发送者和接收者之间共享的密钥，输出为固定长度的数据，这个数据称为MAC值。</li><li>要计算MAC必须持有密钥，没有密钥就无法计算MAC，该特性保证了消息来自期待的对象。</li></ul></li><li>数字签名：不但可以保证数据的完整性和确认消息是否来自期待的对象。而且可以保证消息的不可否认性。<ul><li>消息认证码无法防止否认是因为消息的发送者和接收者共享同一个密钥。两者都可以用该密钥构建出MAC。</li><li>而数字签名是使用签名密钥来生成签名，使用验证密钥来验证签名是否期待的对象签发，验证密钥无法生成签名。和非对称加密类似。但是是使用私钥加密、公钥解密。</li></ul></li><li>公钥证书：对公钥添加数字签名后就得到了公钥证书。<ul><li>CA是证书的签发机构，是负责签发证书、认证证书、管理已颁发证书的机关。如果一个用户想鉴别另一个证书的真伪，可以用CA的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。</li></ul></li></ul><h3 id="数字签名实现"><a href="#数字签名实现" class="headerlink" title="数字签名实现"></a>数字签名实现</h3><ol><li>通常是先对数据进行一次Hash摘要(SHA1/SHA256/SHA512等)，然后再使用非对称加密算法(RSA/ECC等)对这个摘要进行加密，这样得到的结果就是原始数据的一个签名。</li><li>用户在验证数据时，只需要使用公钥解密出Hash摘要，然后自己再对数据进行一次同样的摘要，对比两个摘要是否相同即可。</li></ol><h3 id="SSH-RSA工作原理"><a href="#SSH-RSA工作原理" class="headerlink" title="SSH-RSA工作原理"></a>SSH-RSA工作原理</h3><ol><li>生成一对密钥，一把专用密钥和一把公用密钥。公用密钥用于对消息进行加密，只有拥有专用密钥的人才能对该消息进行解密。</li><li>把公用密钥拷贝到远程服务器的文件(~/.ssh/authorized_keys)里。</li><li>本地输入ssh drobbins@remotebox登录到远程。</li><li>服务端的sshd会生成一个伪随机数，并用我们先前拷贝过去的公用密钥对这个随机数进行加密。然后，sshd把加密了的随机数发回给客户端的ssh。</li><li>客户端对这个随机数进行解密后，再把它发回给服务端。</li><li>服务端允许客户端登录。</li></ol><h3 id="OpenVPN消息发送流程"><a href="#OpenVPN消息发送流程" class="headerlink" title="OpenVPN消息发送流程"></a>OpenVPN消息发送流程</h3><ol><li>客户端将自己的公钥发送给服务端。</li><li>服务端通过CA证书验证公钥是自己签发的，并将密匙通过客户端公钥加密后发送给客户端。</li><li>客户端使用私钥解密获取对称加密的密钥。</li><li>客户端通过对称加密的密匙加密消息并发送给服务端，服务端通过该密钥解密。</li><li>服务端发送消息给客户端同理。</li></ol><h3 id="JWT实现方式"><a href="#JWT实现方式" class="headerlink" title="JWT实现方式"></a><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JWT实现方式</a></h3><ol><li>HS256(HMAC-SHA256)：使用同一个secret_key进行签名与验证(对称加密)。一旦secret_key泄漏，就毫无安全性可言了。因此HS256只适合集中式认证，签名和验证都必须由可信方进行。</li><li>RS256(RSA-SHA256)：使用RSA私钥进行签名，使用RSA公钥进行验证。公钥即使泄漏也毫无影响，只要确保私钥安全就行。RS256可以将公钥给第三方应用，让第三方应用也可以验证登录信息(微信登录原理)。</li><li>ES256(ECDSA-SHA256)： 和RS256一样，都使用私钥签名，公钥验证。算法速度上差距也不大，但是它的签名长度相对短很多(省流量)，并且算法强度和RS256差不多。</li></ol><h3 id="SSL-TLS协议运行机制的概述"><a href="#SSL-TLS协议运行机制的概述" class="headerlink" title="SSL/TLS协议运行机制的概述"></a><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础加密技术&quot;&gt;&lt;a href=&quot;#基础加密技术&quot; class=&quot;headerlink&quot; title=&quot;基础加密技术&quot;&gt;&lt;/a&gt;基础加密技术&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对称密码(AES)：加密和解密使用同一把密匙的加密算法。&lt;ul&gt;
&lt;li&gt;ECB模式：直接切割明文然后加密成密文，简单、快速、不安全。&lt;/li&gt;
&lt;li&gt;CBC模式：TLS/SSL使用该模式，推荐使用。&lt;/li&gt;
&lt;li&gt;CFB模式、OFB模式和CTR模式都是安全的模式，不太能分清优缺点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公钥密码(RSA)：使用公匙加密，私匙解密的加密算法。
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件操作</title>
    <link href="http://yoursite.com/2020/10/18/%E5%9F%BA%E7%A1%80%E4%B9%8BLinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/10/18/基础之Linux文件操作/</id>
    <published>2020-10-18T02:13:20.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通用I-O"><a href="#通用I-O" class="headerlink" title="通用I/O"></a>通用I/O</h2><h3 id="基础的系统调用"><a href="#基础的系统调用" class="headerlink" title="基础的系统调用"></a>基础的系统调用</h3><ul><li>open()和close(): 打开和关闭文件。</li><li>write()和read(): 读写打开的文件。</li><li>lseek(): 设置打开的文件的偏移量。</li><li>ioctl(): 对IO设备的非通用属性进行操作。</li><li>fcntl(): 获取和设置打开文件的熟悉，O_NONBLOCK等。</li><li>dup()和dup2(): 复制文件描述符，2&gt;&amp;1==dup2(1, 2)。</li><li>pwrite()和pread(): 在给定的偏移量上进行读写操作。</li><li>truncate()和ftruncate(): 将文件设置未指定的大小。如果文件大于指定的size，大于的部分丢失。小于则形成文件空洞。<a id="more"></a></li></ul><h3 id="数据同步的系统调用"><a href="#数据同步的系统调用" class="headerlink" title="数据同步的系统调用"></a>数据同步的系统调用</h3><ul><li>fsync()和fdatasync(): 强制刷新缓存数据到文件中。fdatasync只会刷新对read()有影响的元数据，如文件大小；fsync()会刷新所有的元数据，即使对数据读取没有影响，如文件的修改时间。</li><li>sync(void): 强制内核缓冲区中包含的所有更新过的文件信息都刷新到磁盘中。一个永久的内核线程会每隔30秒刷新一次缓存到磁盘。</li><li>打开文件时添加O_SYNC标记: 让写操作自动的刷新文件数据和元数据(fsync)到磁盘中。O_DSYNC标记则类比(fdatasync)。<br>IO数据同步</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通用I-O&quot;&gt;&lt;a href=&quot;#通用I-O&quot; class=&quot;headerlink&quot; title=&quot;通用I/O&quot;&gt;&lt;/a&gt;通用I/O&lt;/h2&gt;&lt;h3 id=&quot;基础的系统调用&quot;&gt;&lt;a href=&quot;#基础的系统调用&quot; class=&quot;headerlink&quot; title=&quot;基础的系统调用&quot;&gt;&lt;/a&gt;基础的系统调用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;open()和close(): 打开和关闭文件。&lt;/li&gt;
&lt;li&gt;write()和read(): 读写打开的文件。&lt;/li&gt;
&lt;li&gt;lseek(): 设置打开的文件的偏移量。&lt;/li&gt;
&lt;li&gt;ioctl(): 对IO设备的非通用属性进行操作。&lt;/li&gt;
&lt;li&gt;fcntl(): 获取和设置打开文件的熟悉，O_NONBLOCK等。&lt;/li&gt;
&lt;li&gt;dup()和dup2(): 复制文件描述符，2&amp;gt;&amp;amp;1==dup2(1, 2)。&lt;/li&gt;
&lt;li&gt;pwrite()和pread(): 在给定的偏移量上进行读写操作。&lt;/li&gt;
&lt;li&gt;truncate()和ftruncate(): 将文件设置未指定的大小。如果文件大于指定的size，大于的部分丢失。小于则形成文件空洞。
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://yoursite.com/2020/08/13/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/13/Python基础/</id>
    <published>2020-08-13T14:24:35.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python数据模型"><a href="#Python数据模型" class="headerlink" title="Python数据模型"></a>Python数据模型</h3><ol><li>Python的特殊方法，如<strong>len</strong>等。Python类实现这些方法，那么在调用len等函数的时候，Python解释器会自动调用这些方法。</li><li>collections.namedtuple用来构建一个带字段名的元组和一个有名字的类，即构建只有少数属性但是没有方法的对象，比如数据库条目。<a id="more"></a></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>列表推导和生成器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">"abcdef"</span></span><br><span class="line">codes = [ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br><span class="line"><span class="comment"># == list(filter(lambda c: c &gt; 127, map(ord, symbols)))</span></span><br><span class="line">beyand = [ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(symbol) &gt; <span class="number">100</span>]</span><br><span class="line">colors = [<span class="string">'black'</span>, <span class="string">'white'</span>]</span><br><span class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</span><br><span class="line">tshirts = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python数据模型&quot;&gt;&lt;a href=&quot;#Python数据模型&quot; class=&quot;headerlink&quot; title=&quot;Python数据模型&quot;&gt;&lt;/a&gt;Python数据模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Python的特殊方法，如&lt;strong&gt;len&lt;/strong&gt;等。Python类实现这些方法，那么在调用len等函数的时候，Python解释器会自动调用这些方法。&lt;/li&gt;
&lt;li&gt;collections.namedtuple用来构建一个带字段名的元组和一个有名字的类，即构建只有少数属性但是没有方法的对象，比如数据库条目。
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础</title>
    <link href="http://yoursite.com/2020/07/11/%E5%85%B6%E5%AE%83%E4%B9%8BDocker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/11/其它之Docker基础/</id>
    <published>2020-07-11T07:33:52.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li>docker info: 查看Docker服务是否正常。</li><li>docker images: 查看所有镜像。</li><li>docker ps -a: 查看当前系统中存在的容器。-a表示无论是否在运行中，都会被查找到。</li><li>docker start/stop name: 启动或停止容器。</li><li>docker rm name: 删除容器。运行中的容器是无法直接删除的，需要先停止容器运行后才能将其删除。</li><li>docker rmi name: 删除Image。</li><li>docker logs -f -t name: 查看容器日志。-f表示用于监控容器的日志，功能类似于tail -f。-t用来添加时间戳。</li><li>docker exec -it name /bin/bash: 在容器内运行进程。</li><li>docker build -t weather:v1.0 ./: 构建一个镜像。</li><li>docker run -d -p 80:8080 –name weather weather:v1.0: 运行镜像。</li><li>docker tag weather:v1.0 fengbo4213/test:v1.0: 给镜像打标签。</li><li>docker push fengbo4213/test:v1.0: 推送到DockerHub。</li><li>docker cp weather:/app ./: 将未启动容器中的内容拷贝出来，方便查看。</li><li>docker inspect name: 查看容器详细信息。<a id="more"></a></li></ul><h3 id="Docker安装phpmyadmin"><a href="#Docker安装phpmyadmin" class="headerlink" title="Docker安装phpmyadmin"></a>Docker安装phpmyadmin</h3><ol><li>下载phpmyadmin镜像: docker pull phpmyadmin/phpmyadmin</li><li>使用该镜像启动容器: docker run -d –name myadmin -e PMA_HOST=192.168.206.132 -e PMA_PORT=3307 -p 8283:80 phpmyadmin/phpmyadmin</li></ol><h3 id="Docker安装Jupyter-Lab"><a href="#Docker安装Jupyter-Lab" class="headerlink" title="Docker安装Jupyter-Lab"></a>Docker安装Jupyter-Lab</h3><ol><li>docker pull jupyter/all-spark-notebook</li><li>docker run -p 8888:8888 -p 4040:4040 –name jupyter -e JUPYTER_ENABLE_LAB=yes -v /usr/local/jupyter:/home/jovyan/work/ jupyter/all-spark-notebook</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本命令&quot;&gt;&lt;a href=&quot;#基本命令&quot; class=&quot;headerlink&quot; title=&quot;基本命令&quot;&gt;&lt;/a&gt;基本命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;docker info: 查看Docker服务是否正常。&lt;/li&gt;
&lt;li&gt;docker images: 查看所有镜像。&lt;/li&gt;
&lt;li&gt;docker ps -a: 查看当前系统中存在的容器。-a表示无论是否在运行中，都会被查找到。&lt;/li&gt;
&lt;li&gt;docker start/stop name: 启动或停止容器。&lt;/li&gt;
&lt;li&gt;docker rm name: 删除容器。运行中的容器是无法直接删除的，需要先停止容器运行后才能将其删除。&lt;/li&gt;
&lt;li&gt;docker rmi name: 删除Image。&lt;/li&gt;
&lt;li&gt;docker logs -f -t name: 查看容器日志。-f表示用于监控容器的日志，功能类似于tail -f。-t用来添加时间戳。&lt;/li&gt;
&lt;li&gt;docker exec -it name /bin/bash: 在容器内运行进程。&lt;/li&gt;
&lt;li&gt;docker build -t weather:v1.0 ./: 构建一个镜像。&lt;/li&gt;
&lt;li&gt;docker run -d -p 80:8080 –name weather weather:v1.0: 运行镜像。&lt;/li&gt;
&lt;li&gt;docker tag weather:v1.0 fengbo4213/test:v1.0: 给镜像打标签。&lt;/li&gt;
&lt;li&gt;docker push fengbo4213/test:v1.0: 推送到DockerHub。&lt;/li&gt;
&lt;li&gt;docker cp weather:/app ./: 将未启动容器中的内容拷贝出来，方便查看。&lt;/li&gt;
&lt;li&gt;docker inspect name: 查看容器详细信息。
    
    </summary>
    
    
      <category term="其它" scheme="http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>HG255D刷OpenWRT</title>
    <link href="http://yoursite.com/2020/06/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8BHG255D%E5%88%B7OpenWRT/"/>
    <id>http://yoursite.com/2020/06/21/路由器之HG255D刷OpenWRT/</id>
    <published>2020-06-21T10:16:28.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路由器就是开发板-HG255D电信原版刷机实战整理-Ubuntu使用USB转TTL"><a href="#路由器就是开发板-HG255D电信原版刷机实战整理-Ubuntu使用USB转TTL" class="headerlink" title="路由器就是开发板 | HG255D电信原版刷机实战整理 | Ubuntu使用USB转TTL"></a><a href="https://blog.csdn.net/aggresss/category_6383458.html" target="_blank" rel="noopener">路由器就是开发板</a> | <a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=143721&amp;highlight=hg255d%20openwrt" target="_blank" rel="noopener">HG255D电信原版刷机实战整理</a> | <a href="http://blog.chinaunix.net/uid-23733005-id-204774.html" target="_blank" rel="noopener">Ubuntu使用USB转TTL</a></h3><a id="more"></a><h3 id="接TTL线"><a href="#接TTL线" class="headerlink" title="接TTL线"></a>接TTL线</h3><p>如下图接线：<br><img src="/img/华为HG255D电信原版无线路由器刷机.jpg"></p><h3 id="Ubuntu安装配置minicom"><a href="#Ubuntu安装配置minicom" class="headerlink" title="Ubuntu安装配置minicom"></a>Ubuntu安装配置minicom</h3><ol><li>安装：sudo apt-get install minicom</li><li>查看USB转串口接入状态：<ul><li>lsmod | grep usbserial</li><li>dmesg | grep ttyUSB0</li></ul></li><li>配置minicom<ol><li>输入命令：sudo minicom -s </li><li>选择“Serial port setup”，出现串口配置菜单</li><li>输入A，修改serial device，由/dev/tty0修改为/dev/ttyUSB0，波特率改为57600</li><li>选择 Save setup as dfl，接着选择Exit退出。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;路由器就是开发板-HG255D电信原版刷机实战整理-Ubuntu使用USB转TTL&quot;&gt;&lt;a href=&quot;#路由器就是开发板-HG255D电信原版刷机实战整理-Ubuntu使用USB转TTL&quot; class=&quot;headerlink&quot; title=&quot;路由器就是开发板 | HG255D电信原版刷机实战整理 | Ubuntu使用USB转TTL&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/aggresss/category_6383458.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;路由器就是开发板&lt;/a&gt; | &lt;a href=&quot;https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;amp;tid=143721&amp;amp;highlight=hg255d%20openwrt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HG255D电信原版刷机实战整理&lt;/a&gt; | &lt;a href=&quot;http://blog.chinaunix.net/uid-23733005-id-204774.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu使用USB转TTL&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>分布式原理</title>
    <link href="http://yoursite.com/2020/03/13/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/13/分布式之分布式原理/</id>
    <published>2020-03-13T12:59:16.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单机存储引擎"><a href="#单机存储引擎" class="headerlink" title="单机存储引擎"></a>单机存储引擎</h3><p>存储系统的基本功能包括:增、删、读、改,其中,读取操作又分为随机读取和顺序扫描。</p><ul><li>哈希存储引擎是哈希表的持久化实现,支持增、删、改,以及随机读取操作,但不支持顺序扫描,对应的存储系统为键值(Key-Value)存储系统。</li><li>B树(B-Tree)存储引擎是B树的持久化实现,不仅支持单条记录的增、删、读、改操作,还支持顺序扫描,对应的存储系统是关系数据库。</li><li>LSM树存储引擎通过将数据的修改增量保存在内存中，读取时需要合并磁盘中的历史数据和内存中的操作记录。支持增、删、改、随机读取以及顺序扫描。<a id="more"></a></li></ul><h3 id="分布式系统数据复制"><a href="#分布式系统数据复制" class="headerlink" title="分布式系统数据复制"></a>分布式系统数据复制</h3><p>客户端将数据写入主副本，主副本将操作日志同步到备副本，备副本回放操作日志，完成后通知主副本。</p><h2 id="分布式协议基础"><a href="#分布式协议基础" class="headerlink" title="分布式协议基础"></a>分布式协议基础</h2><ul><li>CAP理论：一个分布式系统不可能同时满足一致性(C:Consistency)、可用性(A:Availability)和分区容错性(P:Partition tolerance)这三个基本要求,最多只能同时满足其中的两项。<ul><li>一致性 (Consistency)：一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。</li><li>可用性 (Availability)：对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。</li><li>分区容错性 (Partition tolerance)：能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。</li></ul></li><li>BASE理论：对CAP中一致性和可用性权衡的结果，其核心思想是即使无法做到强一致性(Strongconsistency),但每个应用都可以根据自身的业务特点,采用适当的方式来使系统达到最终一致性(Eventualconsistency)。<ul><li>基本可用：基本可用是指分布式系统在出现不可预知故障的时候,允许损失部分可用性。响应时间上的损失:正常情况下,一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果,但由于出现故障(比如系统部分机房发生断电或断网故障),查询结果的响应时间增加到了1~2秒；功能上的损失:正常情况下,在一个电子商务网站上进行购物,消费者儿乎能够顺利地完成每一笔订单,但是在一些节日大促购物高峰的时候,由于消费者的购物行为激增,为了保护购物系统的稳定性,部分消费者可能会被引导到一个降级页面。</li><li>弱状态也称为软状态,和硬状态相对,是指允许系统中的数据存在中间状态,并认为该中间状态的存在不会影响系统的整体可用性,即允许系统在不同节点的数据副本之间进行数据吟步的过程存在延时。</li><li>最终一致性强调的是系统中所有的数据副本,在经过一段时间的同步后,最终能够达到一个一致的状态。因此,最终一致性的本质是需要系统保证最终数据能够达到一致,而不需要实时保证系统数据的强一致性。</li></ul></li></ul><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的,利用该协议能够非常方便地完成所有分布式事务参与者的协调,统一决定事务的提交或回漫,从而能够有效地保证分布式数据一致性。<br>阶段一:提交事务请求</p><ol><li>事务询问。协调者向所有的参与者发送事务内容,询问是否可以执行事务提交操作,并开始等待各参与者的响应。</li><li>执行事务。各参与者节点执行事务操作,并将Undo和Redo信息记人事务日志中。</li><li>各参与者向协调者反馈事务询问的响应。如果参与者成务执行了事务操作,那么就反馈给协调者Yes响应,表示事务可以执行;如果参与者没有成功执行事务,那么就反馈给协调者No响应,表示事务不可以执行。</li></ol><p>阶段二:假如协调者从所有的参与者获得的反馈都是Yes响应,那么就会执行事务提交。</p><ol><li>发送提交请求。协调者向所有参与者节点发出Commit请求。</li><li>事务提交。参与者接收到Commit请求后,会正式执行事务提交操作,并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li>反馈事务提交结果。参与者在完成事务提交之后,向协调者发送Ack消息。</li></ol><p>阶段二:假如任何一个参与者向协调者反馈了No响应,或者在等待超时之后,协调者尚无法接收到所有参与者的反馈响应,那么就会中断事务。</p><ol><li>发送回滚请求。协调者向所有参与者节点发出Rollback请求。</li><li>事务回滚。参与者接收到Rollback请求后,会利用其在阶段一中记录的Undo信息来执行事务回滚操作,并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果。参与者在完成事务回滚之后,向协调者发送Ack消息。</li><li>中断事务。协调者接收到所有参与者反馈的Ack消息后,完成事务中断。</li></ol><h3 id="两阶段提交的问题"><a href="#两阶段提交的问题" class="headerlink" title="两阶段提交的问题"></a>两阶段提交的问题</h3><ol><li>同步阻塞:二阶段提交协议存在的最朋显也是最大的一分布式系统的性能。在二阶段提交的执行过于阻塞状态,也就是说,各个参与者在等待具他任何操作。个问题就是同步阻塞,这会极大地限制程中,所有参与该事务操作的逻辑都处其他参与者响应的过程中,将无法进行其他任何操作。</li><li>单点问题:协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题,那么整个二阶段提交流程将无法运转,更为严重的是,如果协调者是在阶段二中出现问题的话,那么其它参与者将会一直处于锁定事务资源的状态中,而无法继续完成事务操作。</li><li>数据不一致:在二阶段提交协议的阶段二,即执行事务提交的时候,当协调者向所有的参与者发送Commit请求之后,发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩澎,导致最终只有部分参与者收到了Commit请求。于是,这部分收到了Commit请求的参与者就会进行事务的提交,而其他没有收到Commit请求的参与者则无法进行事务提交,于是整个分布式系统便出现了数据不一致性现象。</li><li>太过保守:如果在协调者指示参与者进行事务提交询问的过程中,参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话,这时协调者只能依靠其自身的超时机制来判断是否需要中断事务,这样的策略显得比较保守。换句话说,二阶段提交协议没有设计较为完善的容错机制,任意一个节点的失败都会导致整个事务的失败。</li></ol><h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>主从备份主要有两种方法：<ol><li>状态转移(State Transfer)：主服务器将完整的状态内容都传输给备份服务器。即将主节点的当前所有数据进行镜像备份，适合冷备份。</li><li>备份状态机(Replicated State Machine)：将需要备份的服务器视为一个确定性状态机——主备以相同的状态启动，以相同顺序导入相同的输入，最后它们就会进入相同的状态、给出相同的输出。</li></ol></li><li>Write-Ahead Logging：对数据文件的修改必须发生在这些修改已经记录到日志之后，也就是先写日志落盘然后写数据。这样就不需要每次提交事务的时候把数据块刷回磁盘，因为出现奔溃的情况下可以用日志来恢复数据。</li></ul><h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a><a href="https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html" target="_blank" rel="noopener">Redis实现分布式锁</a></h2><h2 id="ZooKeeper的典型应用场景"><a href="#ZooKeeper的典型应用场景" class="headerlink" title="ZooKeeper的典型应用场景"></a>ZooKeeper的典型应用场景</h2><h3 id="ZooKeeper简介"><a href="#ZooKeeper简介" class="headerlink" title="ZooKeeper简介"></a>ZooKeeper简介</h3><p>ZooKeeper是一个高可用的分布式数据管理与协调框架。基于对ZAB算法的实现,该框架能够很好地保证分布式环境中数据的一致性。也正是基于这样的特性，使得ZooKeeper成为了解决分布式一致性问题的利器。</p><h3 id="数据的发布-订阅"><a href="#数据的发布-订阅" class="headerlink" title="数据的发布/订阅"></a>数据的发布/订阅</h3><ul><li>即所谓的配置中心,顾名思义就是发布者将数据发布到ZooKeeper的一个或一系列节点上,供订阅者进行数据订阅,进而达到动态获取数据的目的,实现配置信息的集中式管理和数据的动态更新。</li><li>客户端向服务端注册自己需要关注的节点,一旦该节点的数据发生变更,那么服务端就会向相应的客户端发送Wateher事件通知,客户端接收到这个消息通知之后,需要主动到服务端获取最新的数据。</li></ul><h3 id="命名服务-Name-Service"><a href="#命名服务-Name-Service" class="headerlink" title="命名服务(Name Service)"></a>命名服务(Name Service)</h3><p>在分布式系统中，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象等一一这些我们都可以统称它们为名字(Name),其中较为常见的就是一些分布式服务框架(如RPC、RMI)中的服务地址列表,通过使用命名服务,客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息等。<br>命名服务器的作用主要有两个，一个是收集提供请求处理的服务器的地址信息;另外一个是提供这些地址信息给请求发起方。当然,名称服务只是起到了一个地址交换的作用,在发起请求的机器上,需要根据从名称服务得到的地址迹行负载均衡的工作。</p><h3 id="集群管理与负载均衡"><a href="#集群管理与负载均衡" class="headerlink" title="集群管理与负载均衡"></a>集群管理与负载均衡</h3><p>ZooKeeper具有以下两大特性。</p><ol><li>客户端如果对ZooKeeper的一个数据节点注册Wateher监听,那么当该数据节点的内容或是其子节点列表发生变更时,ZooKeeper服务器就会向订阅的客户端发送变更通知。</li><li>对在ZooKeeper上创建的临时节点,一旦客户端与服务器之间的会话失效,那么该临时节点也就被自动清除。<br>利用ZooKeeper的这两大特性,就可以实现集群机器存活性监控系统。监控系统在/cuserServers节点上注册一个Watcher监听,那么但凡进行动态添加机器的操作,就会在/clusterServers节点下创建一个临时节点:/cliisterServers/[HostName]。这样一来,监控系统就能够实时检测到机器的变动情况。<br>同时集群上的服务器可以在监听到Watcher事件时，去ZooKeeper拉取集群上所有服务器的基础信息，然后以这些信息为基础进行软负载均衡。</li></ol><h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><ul><li>在分布式系统中,Master往往用来协调集群中其他系统单元,具有对分布式系统状态变更的决定权。例如,在一些读写分离的应用场景中,客户端的写请求往往是由Master来处理的;而在另一些场景中,Master则常常负责处理一些复杂的逻辑,些将处理结果同步给集群中其他系统单元。</li><li>ZooKeeper能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性,即ZooKeeper将会保证客户端无法重复创建一个已经存在的数据节点。也就是说,如果同时有多个客户端请求创建同一个节点,那么最终一定只有一个客户端请求能够创建成功。利用这个特性,就能很容易地在分布式环境中进行Master选举了。</li><li>即所有客户端都去向ZooKeeper请求创建一个临时节点,例如/maser_efecrion/2013-09-20/binding。在这个过程中,只有一个客户端能够成功创建这个节点,那么这个客户端所在的机器就成为了Master。同时,其他没有在ZooKeeper上成功创建节点的客户端,都会在节点/maser_elecrion/2013-09-20上注册一个子节点变更的Watcher,用于监控当前的Master机器是否存活,一旦发现当前的Master挂了,那么其余的客户端将会重新进行Master选举。</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ol><li>获取锁：在需要获取排他锁时,所有的客户端都会试图通过调用create()接口,在/exclusive_lock节点下创建临时子节点/exclusive_lock/lock。ZooKeeper会保证在所有的客户端中,最终只有一个客户端能够创建成功,那么就可以认为该客户端获取了锁。同时,所有没有获取到锁的客户端谐需要到/excliusive_lock节点上注册一个子节点变更的Watcher监听,以便实时监听到lock节点的变更情况。</li><li>释放锁：/exelsive_lock/lock是一个临时节点,因此在以下两种情况下,都有可能释放锁。<ul><li>当前获取锁的客户端机器发生宕机,那么ZooKeeper上的这个临时节点就会被移除。</li><li>正常执行完业务逻辑后,客户端就会主动将自已创建的临时节点删除。<br>无论在什么情况下移除了lock节点,ZooKeeper都会通知所有在/exclusive_lock节点上注册了子节点变更Wateher监听的客户端。这些客户端在接收到通知后,再次重新发起分布式锁获取,即重复获取锁过程。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单机存储引擎&quot;&gt;&lt;a href=&quot;#单机存储引擎&quot; class=&quot;headerlink&quot; title=&quot;单机存储引擎&quot;&gt;&lt;/a&gt;单机存储引擎&lt;/h3&gt;&lt;p&gt;存储系统的基本功能包括:增、删、读、改,其中,读取操作又分为随机读取和顺序扫描。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希存储引擎是哈希表的持久化实现,支持增、删、改,以及随机读取操作,但不支持顺序扫描,对应的存储系统为键值(Key-Value)存储系统。&lt;/li&gt;
&lt;li&gt;B树(B-Tree)存储引擎是B树的持久化实现,不仅支持单条记录的增、删、读、改操作,还支持顺序扫描,对应的存储系统是关系数据库。&lt;/li&gt;
&lt;li&gt;LSM树存储引擎通过将数据的修改增量保存在内存中，读取时需要合并磁盘中的历史数据和内存中的操作记录。支持增、删、改、随机读取以及顺序扫描。
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络管理和优化</title>
    <link href="http://yoursite.com/2020/02/08/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/02/08/树莓派之网络管理和优化/</id>
    <published>2020-02-08T03:59:16.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ol><li><p>使用nmap进行网络扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sP 192.168.0.*</span><br></pre></td></tr></table></figure></li><li><p>查看流量是从哪些端口发送出去的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iftop -P</span><br></pre></td></tr></table></figure></li></ol><p>TX：发送流量<br>RX：接收流量<br>TOTAL：总流量<br>Cumm：运行iftop到目前时间的总流量<br>peak：流量峰值<br>rates：分别表示过去 2s 10s 40s 的平均流量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络管理&quot;&gt;&lt;a href=&quot;#网络管理&quot; class=&quot;headerlink&quot; title=&quot;网络管理&quot;&gt;&lt;/a&gt;网络管理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用nmap进行网络扫描&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>利用VNC远程控制树莓派</title>
    <link href="http://yoursite.com/2020/01/29/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E5%88%A9%E7%94%A8VNC%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>http://yoursite.com/2020/01/29/树莓派之利用VNC远程控制树莓派/</id>
    <published>2020-01-29T10:44:51.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设置树莓派启动方式"><a href="#设置树莓派启动方式" class="headerlink" title="设置树莓派启动方式"></a>设置树莓派启动方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="OpenVPN"><a href="#OpenVPN" class="headerlink" title="OpenVPN"></a>OpenVPN</h2><h3 id="OpenVPN客户端和服务器端安装-OpenVPN配置详解"><a href="#OpenVPN客户端和服务器端安装-OpenVPN配置详解" class="headerlink" title="OpenVPN客户端和服务器端安装 | OpenVPN配置详解"></a><a href="https://www.ilanni.com/?p=9837" target="_blank" rel="noopener">OpenVPN客户端和服务器端安装</a> | <a href="https://www.ilanni.com/?p=9847" target="_blank" rel="noopener">OpenVPN配置详解</a></h3><h2 id="VPC软件"><a href="#VPC软件" class="headerlink" title="VPC软件"></a>VPC软件</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li>服务端安装并运行VNC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tightvncserver</span><br><span class="line">tightvncserver</span><br></pre></td></tr></table></figure></li></ol><p>然后设置密码，输入控制密码，选择性输入查看密码，查看密码只能用来查看桌面，而控制密码才能对桌面进行操作。每个用户可以启动多个VNCSERVER远程桌面，它们用ip加端口号：ip:1、ip:2、ip:3 来标识、区分，使用同一端口会使另外登录的用户自动退出。</p><ol start="2"><li>停止VNC窗口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vncserver -kill:1</span><br><span class="line"># 修改密码</span><br><span class="line">vncpasswd</span><br><span class="line"># 重启服务</span><br><span class="line">service vncserver restart</span><br></pre></td></tr></table></figure></li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>Windows10可以直接安装TightVNC Viewer。</li><li>安卓手机可以安装RealVNC Viewer。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;设置树莓派启动方式&quot;&gt;&lt;a href=&quot;#设置树莓派启动方式&quot; class=&quot;headerlink&quot; title=&quot;设置树莓派启动方式&quot;&gt;&lt;/a&gt;设置树莓派启动方式&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo raspi-config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>树莓派实现NAS家庭服务器</title>
    <link href="http://yoursite.com/2020/01/28/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E5%AE%9E%E7%8E%B0NAS%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/28/树莓派之实现NAS家庭服务器/</id>
    <published>2020-01-28T07:25:35.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="挂载移动硬盘"><a href="#挂载移动硬盘" class="headerlink" title="挂载移动硬盘"></a>挂载移动硬盘</h3><ol><li><p>插上硬盘，查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure></li><li><p>挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda5 /home/pi/samba</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h3 id="安装DLNA实现流媒体服务器"><a href="#安装DLNA实现流媒体服务器" class="headerlink" title="安装DLNA实现流媒体服务器"></a>安装DLNA实现流媒体服务器</h3><ol><li><p>安装minidlna。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install minidlna</span><br></pre></td></tr></table></figure></li><li><p>设置/etc/minidlna.conf文件，在文件尾部添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># A表示这个目录是存放音乐的，当minidlna读到配置文件时，它会自动加载这个目录下的音乐文件</span><br><span class="line">media_dir=A,/home/pi/samba/DLNA/Music</span><br><span class="line">media_dir=P,/home/pi/samba/DLNA/Picture</span><br><span class="line">media_dir=V,/home/pi/samba/DLNA/Video</span><br><span class="line"># 配置minidlna的数库数据的存放目录</span><br><span class="line">db_dir=/home/pi/samba/DLNA/db</span><br><span class="line"># 配置日志目录</span><br><span class="line">log_dir=/home/pi/samba/DLNA/log</span><br></pre></td></tr></table></figure></li><li><p>在相应位置建立以上文件夹，并设置好权限为。</p></li><li><p>重启minidlna。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service minidlna restart</span><br></pre></td></tr></table></figure></li><li><p>电脑上可以使用VLC播放器，View &gt; Playlist[CTRL + L] &gt; Local Network。</p></li><li>手机可以使用MoliPlayer或者VLC。</li></ol><h3 id="安装aria2实现下载机功能"><a href="#安装aria2实现下载机功能" class="headerlink" title="安装aria2实现下载机功能"></a>安装aria2实现下载机功能</h3><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aria2</span><br><span class="line">sudo mkdir /etc/aria2 </span><br><span class="line">sudo touch /etc/aria2/aria2.session </span><br><span class="line">sudo chmod 777 /etc/aria2/aria2.session </span><br><span class="line">sudo chgrp -R pi /home/pi/samba/DLNA/Video</span><br><span class="line">sudo chown -R pi /home/pi/samba/DLNA/Video</span><br><span class="line">sudo vi /etc/aria2/aria2.conf</span><br></pre></td></tr></table></figure></li><li><p><a href="http://www.senra.me/aria2-conf-file-parameters-translation-and-explanation/" target="_blank" rel="noopener">aria2.conf文件配置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dir=/home/pi/samba/DLNA/Video</span><br><span class="line">disable-ipv6=true</span><br><span class="line"></span><br><span class="line">#打开rpc的目的是为了给web管理端用</span><br><span class="line">enable-rpc=true</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#rpc-listen-port=6800</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">input-file=/etc/aria2/aria2.session</span><br><span class="line">save-session=/etc/aria2/aria2.session</span><br><span class="line"></span><br><span class="line">#最大同时下载任务数</span><br><span class="line">max-concurrent-downloads=20</span><br><span class="line">save-session-interval=120</span><br><span class="line"></span><br><span class="line"># Http/FTP 相关</span><br><span class="line">connect-timeout=120</span><br><span class="line">#lowest-speed-limit=10K</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=10</span><br><span class="line">#max-file-not-found=2</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line"></span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">check-certificate=false</span><br><span class="line">#http-no-cache=true</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aria2c --conf-path=/etc/aria2/aria2.conf</span><br></pre></td></tr></table></figure></li></ol><p>如果没有提示错误，按ctrl+c停止运行命令，转为后台运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br></pre></td></tr></table></figure></p><ol start="4"><li>参数使用<br>使用 aria2 下载文件，只需在命令后附加地址即可。注意：命令是aria2c。比如我们下载ubuntu如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c http://www.mirror.tw/pub/ubuntu/releases/jaunty/ubuntu-9.04-desktop-i386.iso</span><br></pre></td></tr></table></figure></li></ol><p>分段下载利用aria2的分段下载功能可以加快文件的下载速度，对于下载大文件时特别有用，为了使用aria2的分段下载功能，你需要在命令中指定s选项，使用c选项可以断点续传文件。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c -c -s10 -x10 http://www.mirror.tw/pub/ubuntu/releases/jaunty/ubuntu-9.04-desktop-i386.iso</span><br></pre></td></tr></table></figure></p><p>下载torrent文件你也可以使用aria2下载BitTorrent文件。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c -o gutsy.torrent http://cdimage.ubuntu.com/daily-live/current/gutsy-desktop-i386.iso.torrent</span><br></pre></td></tr></table></figure></p><ol start="5"><li>aria2安装Web界面<ol><li><a href="https://github.com/binux/yaaw" target="_blank" rel="noopener">下载yaaw</a></li><li>将下载下来的静态文件放到HTTP服务器的工作目录中。</li><li>使用浏览器访问该服务器并点击右上角的扳手按钮配置aria2。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;挂载移动硬盘&quot;&gt;&lt;a href=&quot;#挂载移动硬盘&quot; class=&quot;headerlink&quot; title=&quot;挂载移动硬盘&quot;&gt;&lt;/a&gt;挂载移动硬盘&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;插上硬盘，查看状态&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo fdisk -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;挂载&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mount /dev/sda5 /home/pi/samba&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>树莓派系统和相关软件安装</title>
    <link href="http://yoursite.com/2020/01/27/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/01/27/树莓派之系统安装/</id>
    <published>2020-01-27T13:05:51.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="官方系统安装"><a href="#官方系统安装" class="headerlink" title="官方系统安装"></a><a href="https://post.smzdm.com/p/738951/" target="_blank" rel="noopener">官方系统安装</a></h3><ol><li>安装SDFormatter4，选好要用的TF卡盘符，然后点击格式化。</li><li>安装Win32DiskImager，点击文件夹图标，选择准备好的img文件，然后点击Write按钮。</li><li>进度条走完之后会弹出两个框，一个是询问是否格式化磁盘，选取消。<a id="more"></a></li></ol><h3 id="将树莓派用做无线路由器"><a href="#将树莓派用做无线路由器" class="headerlink" title="将树莓派用做无线路由器"></a><a href="https://www.cnblogs.com/jins-note/p/9513594.html" target="_blank" rel="noopener">将树莓派用做无线路由器</a></h3><ol><li><p>安装hostapd。并修改/etc/default/hostapd和/etc/hostapd/hostapd.conf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 使用如下命令</span><br><span class="line">sudo apt remove --purge hostapd </span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install hostapd</span><br><span class="line"></span><br><span class="line"># 在/etc/default/hostapd中添加</span><br><span class="line">DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;</span><br><span class="line"></span><br><span class="line"># 在hostapd.conf中添加</span><br><span class="line"># 把无线网卡wlan0作为接入点</span><br><span class="line">interface=wlan0</span><br><span class="line"># 使用nl80211驱动</span><br><span class="line">#driver=nl80211</span><br><span class="line"># a 5G g 2.4G</span><br><span class="line">hw_mode=g</span><br><span class="line"># 无线网卡选用11信道，如果hw_mode为a可以选择165</span><br><span class="line">channel=11</span><br><span class="line">ieee80211n=1</span><br><span class="line">ieee80211ac=1</span><br><span class="line">wmm_enabled=1</span><br><span class="line"></span><br><span class="line"># WPA2 only</span><br><span class="line">wpa=2</span><br><span class="line"># 1=wpa 2=wep 3=both</span><br><span class="line">auth_algs=3</span><br><span class="line"># 认证方式为WPA-PSK加密方式为CCMP</span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line">wpa_pairwise=CCMP</span><br><span class="line">rsn_pairwise=CCMP</span><br><span class="line"></span><br><span class="line"># Wifi名称</span><br><span class="line">ssid=wifi123</span><br><span class="line"># Wifi密码</span><br><span class="line">wpa_passphrase=feng4213</span><br></pre></td></tr></table></figure></li><li><p>安装dnsmasq。并修改/etc/dnsmasq.conf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在dnsmasq.conf中添加</span><br><span class="line">interface=wlan0</span><br><span class="line">dhcp-range=192.168.202.10,192.168.202.150,255.255.255.0,24h</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/rc.local文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在exit 0之前添加</span><br><span class="line">sudo ifconfig wlan0 down</span><br><span class="line">sudo ifconfig wlan0 192.168.202.1 netmask 255.255.255.0 up</span><br><span class="line"># 关闭无线网络的电源管理</span><br><span class="line">sudo iw dev wlan0 set power_save off</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br><span class="line">sudo service hostapd restart</span><br><span class="line">sudo service dnsmasq restart</span><br></pre></td></tr></table></figure></li></ol><h3 id="利用ssh反向代理及autossh实现内网穿透"><a href="#利用ssh反向代理及autossh实现内网穿透" class="headerlink" title="利用ssh反向代理及autossh实现内网穿透"></a>利用ssh反向代理及autossh实现内网穿透</h3><ol><li>内网和外网机器安装autossh。</li><li><p>内网机器配置免密登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@外网地址</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上启动autossh。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -f：是指autossh后台运行，不会阻塞shell继续向下执行；</span><br><span class="line"># -N：是指建立的ssh连接只用于转发数据，不解析命令； </span><br><span class="line"># -R：是指建立反向隧道，一般我们ssh某个服务器是正向隧道； </span><br><span class="line"># 8888：是公网服务器上的代理端口；</span><br><span class="line"># localhost:22：是指代理到本机时需要访问的ip和端口，即内网机器A的ip地址+端口；</span><br><span class="line"># -p 40022：是外网机器B的ssh端口；</span><br><span class="line">autossh -fNR 8888:localhost:22 -p 22 root@外网地址</span><br></pre></td></tr></table></figure></li><li><p>在外网上查看8888端口是否打开。</p></li><li>在外网主机上连接内网主机。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 8888 localhost -l pi</span><br></pre></td></tr></table></figure></li></ol><h3 id="设置autossh自动启动"><a href="#设置autossh自动启动" class="headerlink" title="设置autossh自动启动"></a>设置autossh自动启动</h3><ol><li><p>新建/etc/systemd/system/remote-autossh.service文件。并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=AutoSSH</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=pi</span><br><span class="line">ExecStart=/usr/bin/autossh -fNR 8888:localhost:22 -p 22 root@118.31.167.239</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -TERM $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=no</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>使用systemctl daemon-reload命令刷新systemctl服务。</p></li><li>使用systemctl start remote-autossh立即启动服务，或者systemctl enable remote-autossh启动服务并设置为开机启动。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;官方系统安装&quot;&gt;&lt;a href=&quot;#官方系统安装&quot; class=&quot;headerlink&quot; title=&quot;官方系统安装&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://post.smzdm.com/p/738951/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方系统安装&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装SDFormatter4，选好要用的TF卡盘符，然后点击格式化。&lt;/li&gt;
&lt;li&gt;安装Win32DiskImager，点击文件夹图标，选择准备好的img文件，然后点击Write按钮。&lt;/li&gt;
&lt;li&gt;进度条走完之后会弹出两个框，一个是询问是否格式化磁盘，选取消。
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ基础</title>
    <link href="http://yoursite.com/2019/11/13/%E5%85%B6%E5%AE%83%E4%B9%8BRocketMQ%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/11/13/其它之RocketMQ基础/</id>
    <published>2019-11-13T04:29:51.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MQ作用"><a href="#MQ作用" class="headerlink" title="MQ作用"></a><a href="https://www.cnblogs.com/javazhiyin/p/13201315.html" target="_blank" rel="noopener">MQ作用</a></h3><p>在一个企业级的架构应用中，MQ的主要作用为业务解耦、事件消息广播、消息流控处理。其中，对于业务解耦是作为消息队列，要解决的一个首要问题。所谓业务解耦，就是说在一个业务流程处理上，只关注具体的流程，尽到通知的责任即可，不必等待消息处理的结果。<br>总得来看，企业级系统模块通信的方式通常情况下，无非两种。同步方式：REST、RPC方式实现；异步方式：消息中间件（消息队列）方式实现。<br><a id="more"></a></p><h3 id="RocketMQ基础组件"><a href="#RocketMQ基础组件" class="headerlink" title="RocketMQ基础组件"></a>RocketMQ基础组件</h3><ul><li>NameServer：相当于注册中心。是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。<ol><li>维护了一份Broker的地址列表。Broker在启动的时候会去NameServer进行注册，并发送心跳来维护Broker的存活状态。</li><li>维护了一份Topic和Topic对应队列的地址列表，Broker每次发送心跳过来的时候都会把Topic信息带上。</li><li>接收客户端（Producer和Consumer）的请求根据某个Topic获取所有到Broker的路由信息。</li></ol></li><li>Broker：负责存储和分发消息。<ul><li>Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。</li><li>每隔30秒（此时间无法更改）向所有NameServer发送心跳，心跳包含了自身的Topic配置信息。</li><li>NameServer每隔10秒钟（此时间无法更改），扫描所有还存活的Broker连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则断开连接。</li></ul></li><li>Producer：消息生产者。与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的所有Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li><li>Consumer：消息消费者。与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的所有Master和Slave建立长连接，且定时向Master和Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</li></ul><h3 id="RocketMQ部署方式"><a href="#RocketMQ部署方式" class="headerlink" title="RocketMQ部署方式"></a>RocketMQ部署方式</h3><ul><li>单个Master：只适合测试环境。</li><li>多Master模式<ul><li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢失（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li></ul></li><li>多Master多Slave模式，异步复制<ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master 宕机后，消费者仍然可以从Slave消费，此过程对应用透明。不需要人工干预。性能同多Master模式几乎一样。</li><li>缺点：Master宕机，磁盘损坏情况，会丢失少量消息。</li></ul></li><li>多Master多Slave模式，同步双写<ul><li>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</li><li>缺点：性能比异步复制模式略低，大约低10%左右，发送单个消息的RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</li></ul></li></ul><h3 id="RocketMQ实现功能"><a href="#RocketMQ实现功能" class="headerlink" title="RocketMQ实现功能"></a>RocketMQ实现功能</h3><ul><li>消息存储：消息中间件的一个核心实现是消息的存储对消息存储一般有如下两个维度的考量: 消息堆积能力和消息存储性能。RocketMQ追求消息存储的高性能，引人内存映射机制，所有主题的消息顺序存储在同一个文件中。同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制。</li><li>消息高可用性：通常影响消息可靠性的有以下几种情况。1.Broker正常关机。2.Broker异常Crash。3.OS Crash。4.机器断电，但是能立即恢复供电情况。5.机器无法开机(可能是CPU、主板、内存等关键设备损坏)。6.磁盘设备损坏。针对上述情况，情况1~4的RocketMQ在同步刷盘机制下可以确保不丢失消息，在异步刷盘模式下，会丢失少量消息。情况5-6属于单点故障，一旦发生，该节点上的消息全部丢失，如果开启了异步复制机制，RoketMQ能保证只丢失少量消息，如果使用Master Slave双写机制，可以保证不丢失消息，从而满足消息可靠性要求极高的场合。</li><li>消费低延迟：RocketMQ在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式。</li><li>确保消息必须被消费一次：RocketMQ通过消息消费确认机制(ACK)来确保消息至少被消费一次，但由于ACK消息有可能丢失等其他原因，RocketMQ无法做到消息只被消费一次，有重复消费的可能。</li><li>回溯消息：回溯消息是指消息消费端已经消费成功的消息，由于业务要求需要重新消费消息。RocketMQ支持按时间回溯消息，时间维度可精确到毫秒，可以向前或向后回溯。</li><li>消息堆积：消息中间件的主要功能是异步解耦，必须具备应对前端的数据洪峰，提高后端系统的可用性，必然要求消息中间件具备一定的消息堆积能力。RocketMQ消息存储使用磁盘文件(内存映射机制)，并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。RocketMQ消息存储文件并不是永久存储在消息服务器端，而是提供了过期机制，默认保留3天。</li><li>定时消息：定时消息是指消息发送到Broker后，不能被消息消费端立即消费，要到特定的时间点或者等待特定的时间后才能被消费。如果要支持任意精度的定时消息消费，必须在消息服务端对消息进行排序，势必带来很大的性能损耗，故RocketMQ不支持任意进度的定时消息，而只支持特定延迟级别。</li><li>消息重试机制：消息重试是指消息在消费时，如果发送异常，消息中间件需要支持消息重新投递，RocketMQ支持消息重试机制。</li></ul><h3 id="RocketMQ路由查找"><a href="#RocketMQ路由查找" class="headerlink" title="RocketMQ路由查找"></a>RocketMQ路由查找</h3><ul><li>Topic路由信息创建<ol><li>手动创建Topic路由信息：可以根据该Topic消息的实际需求，分配合适的Broker数量和消息队列数量。一般来说，生产环境的服务都推荐以这种方式进行。</li><li>打开自动创建Topic功能：配置BrokerConfig#autoCreateTopicEnable，这样就会在发送第一个消息时，动态的创建该topic的路由信息。</li></ol></li><li>路由选择<ol><li>轮训所有队列，通过LatencyFaultTolerance找到可用队列。</li><li>如果未找到任何可用队列，通过LatencyFaultTolerance存储的信息，按照三个纬度的可用性排序（当前可用与否&gt;上次使用该节点时的调用耗时&gt;预估的下次可使用时间），选出最可能可用的队列。</li><li>如果上述两个步骤都没有选出队列，则按照最简单的轮训找到下一个队列。</li></ol></li></ul><h3 id="RocketMQ消息存储"><a href="#RocketMQ消息存储" class="headerlink" title="RocketMQ消息存储"></a>RocketMQ消息存储</h3><p>RocketMQ主要存储的文件包括CommitLog文件、ConsumeQueue文件、IndexFile文件。</p><ul><li>CommitLog：消息存放的物理文件。CommitLog的消息存储单元长度不固定，文件顺序写，随机读。</li><li>ConsumeQueue：是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。</li><li>IndexFile：索引文件，引入了Hash索引机制为消息建立索引，对CommitLog进行数据索引。</li></ul><h2 id="RocketMQ应用"><a href="#RocketMQ应用" class="headerlink" title="RocketMQ应用"></a>RocketMQ应用</h2><h3 id="系统I-O和虚拟内存设置"><a href="#系统I-O和虚拟内存设置" class="headerlink" title="系统I/O和虚拟内存设置"></a>系统I/O和虚拟内存设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 内存分配策略</span><br><span class="line"># 可选值：0、1、2</span><br><span class="line"># 0：表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。即内核计算NR_FILE_PAGES总量+SWAP总量+slab中可以释放的内存总量，如果申请空间超过此数值，则将此数值与空闲内存总量减掉totalreserve_pages的总量相加。如果申请空间依然超过此数值，则分配失败。</span><br><span class="line"># 1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</span><br><span class="line"># 2：表示内核允许分配超过所有物理内存和交换空间总和的内存。</span><br><span class="line">echo &apos;vm.overcommit_memory=1&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 表示强制Linux VM最低保留多少空闲内存（Kbytes）。当可用内存低于这个参数时，系统开始回收cache内存，以释放内存，直到可用内存大于这个值。RocketMQ需要大量使用页缓存，故需要适当小的设置该值。</span><br><span class="line">echo &apos;vm.min_free_kbytes=5000000&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">echo &apos;vm.drop_caches=1&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 在申请内存时，内核在当前zone(内存页)内没有足够内存可用的情况下，会根据zone_reclaim_mode的设置来决策是从下一个zone找空闲内存还是在zone内部进行回收。</span><br><span class="line"># 0：意味着关闭zone_reclaim模式，可以从其他zone或NUMA节点回收内存。</span><br><span class="line"># 1：表示打开zone_reclaim模式，这样内存回收只会发生在本地节点内。</span><br><span class="line"># 2：在本地回收内存时，可以将cache中的脏数据写回硬盘，以回收内存。</span><br><span class="line"># 3：可以用swap方式回收内存。</span><br><span class="line">echo &apos;vm.zone_reclaim_mode=0&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 一个进程可以拥有的VMA(虚拟内存区域)的数量。虚拟内存区域是一个连续的虚拟地址空间区域。</span><br><span class="line">echo &apos;vm.max_map_count=655360&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 指定了当文件系统缓存脏页数量达到系统内存百分之多少时(如5%)就会触发pdflush/flush/kdmflush等后台回写进程运行，将一定缓存的脏页异步地刷入磁盘。</span><br><span class="line">echo &apos;vm.dirty_background_ratio=50&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 指定了当文件系统缓存脏页数量达到系统内存百分之多少时(如10%)，新的IO请求将会被阻挡，直到脏数据被写进磁盘。这是造成IO卡顿的重要原因，但这也是保证内存中不会存在过量脏数据的保护机制。</span><br><span class="line">echo &apos;vm.dirty_ratio=50&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 用来控制从swap空间换入数据的时候，一次连续读取的页数，这相当于对交换空间的预读。</span><br><span class="line">echo &apos;vm.page-cluster=3&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># 指定多长时间pdflush/flush/kdmflush这些进程会唤醒一次，然后检查是否有缓存需要清理。</span><br><span class="line">echo &apos;vm.dirty_writeback_centisecs=360000&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># swappiness=0的时候表示最大限度使用物理内存，然后才是swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。Linux的基本默认设置为60。</span><br><span class="line">echo &apos;vm.swappiness=10&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><h3 id="系统文件句柄设置"><a href="#系统文件句柄设置" class="headerlink" title="系统文件句柄设置"></a>系统文件句柄设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以打开最大文件描述符的数量。</span><br><span class="line">echo &apos;ulimit -n 1000000&apos; &gt;&gt; /etc/profile</span><br><span class="line"># admin用户可用的最大进程数量(硬限制)。</span><br><span class="line">echo &apos;admin hard nofile 1000000&apos; &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MQ作用&quot;&gt;&lt;a href=&quot;#MQ作用&quot; class=&quot;headerlink&quot; title=&quot;MQ作用&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/javazhiyin/p/13201315.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MQ作用&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在一个企业级的架构应用中，MQ的主要作用为业务解耦、事件消息广播、消息流控处理。其中，对于业务解耦是作为消息队列，要解决的一个首要问题。所谓业务解耦，就是说在一个业务流程处理上，只关注具体的流程，尽到通知的责任即可，不必等待消息处理的结果。&lt;br&gt;总得来看，企业级系统模块通信的方式通常情况下，无非两种。同步方式：REST、RPC方式实现；异步方式：消息中间件（消息队列）方式实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="其它" scheme="http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://yoursite.com/2019/10/10/%E5%9F%BA%E7%A1%80%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/10/10/基础之HTTP协议/</id>
    <published>2019-10-10T02:22:43.000Z</published>
    <updated>2021-07-03T01:30:27.672Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/duoani/HTTP-RFCs.zh-cn" target="_blank" rel="noopener">RFC文档</a><br><a id="more"></a></p><h3 id="HTTP请求消息的解析"><a href="#HTTP请求消息的解析" class="headerlink" title="HTTP请求消息的解析"></a>HTTP请求消息的解析</h3><p>解析HTTP消息的一般流程是先将起始行读入到一个构造体中，将所有头字段读入到一个哈希表中（以字段的名称作为键）直到遇到空行，然后使用以上解析得到的信息来决定是否需要消息体。如果消息头表明消息带有消息体，那么将消息体以流的方式读入，直到已读字节数等于消息体的长度或者连接已被关闭为止。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li>1xx(Informational)：这是一个过渡响应，用于在完成所请求的动作以及发送一个最终响应之前传递连接状态或请求进展。</li><li>2xx(Successful)：客户端的请求已经被成功接收、理解和接受。</li><li>3xx (Redirection)：需要用户代理采取进一步的动作才能实现这个请求。如果提供了一个 Location头字段，用户代理可以自动重定向它的请求到Location的字段值所指定的URI引用，即使它不理解具体的状态码。<ul><li>301：在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。</li><li>302：与301状态码类似，但是，客户端应该使用Location首部给出的URL来临时定位资源，将来的请求仍然使用老的URL。</li><li>304：如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。</li></ul></li><li>4xx(Client Error)状态码种类表明客户端貌似有错误。</li><li>5xx(Server Error)状态码种类表明服务器意识到它有错误或者它无法执行所请求的方法。</li></ul><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP首部</a></h2><h3 id="通用首部：客户端和服务器都可以使用"><a href="#通用首部：客户端和服务器都可以使用" class="headerlink" title="通用首部：客户端和服务器都可以使用"></a>通用首部：客户端和服务器都可以使用</h3><ul><li>Cache-Control：指定缓存的工作机制。</li><li>Connection：<ul><li>Connection: 不再转发的首部字段名 – 指明那些首部不会被转发，即这些首部为逐跳hop-by-hop首部。</li><li>Connection: keep-alive – 在HTTP1.0中表明该连接时长连接。</li><li>Connection: close – 在HTTP1.1中表示关闭该连接。</li></ul></li><li>Transfer-Encoding：告诉接收端为了保证报文的可靠传输，对报文采用什么编码方式。该首部是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。<ul><li>Transfer-Encoding: chunked – 表明报文时分块传输的。</li></ul></li><li>Date：表明创建HTTP报文的日期和时间。</li><li>Via：显示报文经过的中间节点（代理、网关）。</li></ul><h3 id="请求首部：请求报文特有"><a href="#请求首部：请求报文特有" class="headerlink" title="请求首部：请求报文特有"></a>请求首部：请求报文特有</h3><ul><li>Host：告知服务器，请求的资源所处的互联网主机名和端口号。虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分。Host头字段的内容是一个关键信息，所以用户代理应该将Host作为头部的第一个字段，紧随于请求行之后。</li><li>Referer：使服务器知道客户端是从哪里获得其请求的URL。</li><li>User-Agent：创建请求的浏览器和用户代理名称等信息传达给服务器。</li><li>Cookie：客户端用它向服务器传递一个令牌。</li><li>Accept：相当于（Accept-type），用来通知服务器用户代理能够处理的媒体类型及媒体类型的相对优先级。例如accept: application/json, text/javascript, <em>/</em>; q=0.01。权重值q的范围是0~1（可精确到小数点后3位），且1为最大值。不指定权重q值时，默认权重为q=1.0。</li><li>Accept-Charset：来通知服务器用户代理支持的字符集及字符集的相对优先顺序。</li><li>Accept-Encoding：段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序</li><li>Accept-Language：用来告知服务器用户代理能够处理的自然语言集。例如Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3。</li></ul><h3 id="响应首部：响应报文特有"><a href="#响应首部：响应报文特有" class="headerlink" title="响应首部：响应报文特有"></a>响应首部：响应报文特有</h3><ul><li>Age：从最初创建开始的响应持续时间。</li><li>Location：对于201(Created)响应，Location的值引用的是由于这个请求而创建的主要资源。对于3xx(Redirection)响应，Location的值引用的是重定向的目标。</li><li>Allow：列出了声明目标资源所支持的一系列方法。这个字段的目的是确切通知给接收端这个资源有哪些有效的请求方法。</li><li>Server：告诉客户端当前服务器上安装的HTTP服务器应用程序信息。</li></ul><h3 id="实体首部：用于说明实体的属性"><a href="#实体首部：用于说明实体的属性" class="headerlink" title="实体首部：用于说明实体的属性"></a>实体首部：用于说明实体的属性</h3><ul><li>Allow：用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。例如Allow: GET, HEAD。</li><li>Content-Encoding：告知客户端服务器对实体的主体部分选用的内容编码方式。例如Content-Encoding: gzip。</li><li>Content-Language：告知客户端，实体主体使用的自然语言（指中文或英文等语言）。例如Content-Language: zh-CN。</li><li>Content-Length：表明了实体主体部分的大小（单位是字节）。例如Content-Length: 15000。</li><li>Content-Type：说明了实体主体内对象的媒体类型。例如Content-Type: text/html; charset=UTF-8。</li></ul><h3 id="常用的Content-Type类型"><a href="#常用的Content-Type类型" class="headerlink" title="常用的Content-Type类型"></a>常用的Content-Type类型</h3><ol><li>application/json：目前的最常用的Content-Type类型，即传递JSON数据。</li><li>application/octet-stream：Postman中的raw模式使用该类型，只可以上传二进制数据。</li><li>application/x-www-form-urlencoded：浏览器使用表单提交数据时默认的编码格式，会将参数转换成key=value&amp;key=value格式，并对数据进行URLEncoder编码，即<b>将键值对的参数用&amp;连接起来，如果有空格，将空格转换为+加号；有特殊符号，将特殊符号转换为ASCII HEX值</b>。对于Get请求，是将参数放在?后面，即?key=value&amp;key=value格式，Post请求则是将key=value&amp;key=value放在请求体（Form Data）中。</li><li>multipart/form-data：一般格式为multipart/form-data; boundary=————————–138759662723671253948031。boundary的值用来分隔每个参数。该类型即可以上传键值对，也可以上传文件，相当于2和3的混合体。</li></ol><h2 id="HTTP性能瓶颈"><a href="#HTTP性能瓶颈" class="headerlink" title="HTTP性能瓶颈"></a>HTTP性能瓶颈</h2><ul><li>TCP连接建立握手和TCP慢启动拥塞控制：慢启动是指TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。</li><li>用于捎带确认的TCP延迟确认算法:<ul><li>TCP协议为了确保数据的可靠传输实现了自己的确认机制。每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。</li><li>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行捎带。TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种延迟确认算法。延迟确认算法会在一个特定的窗口时间（通常是100～200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</li><li>但是，HTTP具有双峰特征的请求，应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</li></ul></li><li>数据聚集的Nagle算法:<ul><li>Nagle算法是指在发送的数据在未被确认前，如果有新的小数据生成，那就把小数据收集起来，等凑足一个MSS或者收到确认后再发送。</li><li>Nagle算法会引发几种HTTP性能问题。首先，小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题——Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100～200毫秒。 </li><li>HTTP应用程序常常会在自己的栈中设置参数TCP_NODELAY，禁用Nagle算法，提高性能。如果要这么做的话，一定要确保会向TCP写入大块的数据，这样就不会产生一堆小分组了。</li></ul></li><li>TIME_WAIT时延和端口耗尽：当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段试用期的两倍（称为2MSL,通常为2分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，这个算法可以防止在2分钟内创建、关闭并重新创建2个相同IP地址和端口号的连接。2MSL的连接关闭延迟通常只有在进行性能基准测试时才有可能出现问题。</li></ul><h3 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h3><p>为了解决TCP连接建立握手和TCP慢启动拥塞控制所带来的网络时延问题，在HTTP/1.0和HTTP/1.1中都引入了长连接的概念。不过长连接需要注意以下几点：</p><ul><li>长连接必须有Content-Length首部或分块传输编码方式编码的连接。</li><li>HTTP/1.0和HTTP/1.1的长连接方式不同。HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接。</li><li>Content-Length字段必须真实反映实体长度，通常如果Content-Length比实际长度短，会造成内容被截断；如果比实体内容长，会造成等待。</li></ul><h3 id="Content-Length的问题"><a href="#Content-Length的问题" class="headerlink" title="Content-Length的问题"></a>Content-Length的问题</h3><ul><li>实际应用中，有些时候实体长度并没那么好获得，例如实体来自于网络文件，或者由动态语言生成。这时候要想准确获取长度，只能开一个足够大的Buffer，等内容全部生成好再计算。但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。</li><li>所以可以使用分块编码(chunked)的方式来传输。在头部加入Transfer-Encoding: chunked之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的CRLF(\r\n)，也不包括分块数据结尾的CRLF。最后一个分块长度值必须为0，对应的分块数据为CRLF，表示实体结束。</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP加上加密处理和认证以及完整性保护后即是HTTPS。</p><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><ul><li>加密和解密同用一个密钥的方式称为对称加密。对称加密进行加密时必须将密钥也发给对方。如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。</li><li>非对称加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</li></ul><h3 id="HTTPS加密方式"><a href="#HTTPS加密方式" class="headerlink" title="HTTPS加密方式"></a>HTTPS加密方式</h3><p>非对称加密处理起来更为复杂效率更低，所以HTTPS使用非对称加密的方式传递对称加密的密匙，再使用对称加密的方式来进行通信。</p><h3 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h3><ol><li>客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件列表(所使用的加密算法及密钥长度等)。</li><li>服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>之后服务器发送Certificate报文。报文中包含公开密钥证书。</li><li>最后服务器发送Server Hello Done报文通知客户端，SSL第一次握手结束。</li><li>客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串(对称加密的密钥)。</li><li>接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。</li><li>客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>服务器同样发送Change Cipher Spec报文和Finished报文。</li><li>服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。</li><li>应用层协议通信，即发送HTTP响应。</li></ol><h3 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h3><p>公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p><ol><li>服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。</li><li>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</li><li>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确服务器的公开密钥是值得信赖的。</li><li>多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a><a href="https://www.oschina.net/question/1397765_172789" target="_blank" rel="noopener">HTTP2.0</a></h2><h3 id="HTTP2-0优势"><a href="#HTTP2-0优势" class="headerlink" title="HTTP2.0优势"></a>HTTP2.0优势</h3><ol><li>基于二进制分帧的多路复用，解决了HTTP1.X的对头阻塞(Head-Of-Line Blocking)问题。</li><li>可以定义请求的优先级。</li><li>使用了首部压缩技术，压缩算法使用HPACK。</li><li>使用首部表来跟踪和存储之前发送的键-值对。首部表在连接过程中始终存在，新增的键-值对会更新到表尾，不需要每次通信都需要再携带首部。 </li><li>增加了服务端推送功能，服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。</li></ol><h3 id="HTTP2-0协商"><a href="#HTTP2-0协商" class="headerlink" title="HTTP2.0协商"></a>HTTP2.0协商</h3><ol><li>基于ALPN的协商过程：客户端在TLS握手Client Hello阶段表明自身支持HTTP2.0。服务端收到后，响应Server Hello，表示自己也支持HTTP2.0。双方开始HTTP 2.0通信。</li><li>基于HTTP的协商过程：客户端也可以使用HTTP Upgrade机制来使用HTTP2.0。客户端和服务端都可以使用Upgrade请求头来携带升级的协议。</li></ol><h2 id="HTTP3-0-队头阻塞"><a href="#HTTP3-0-队头阻塞" class="headerlink" title="HTTP3.0 - 队头阻塞"></a>HTTP3.0 - <a href="https://zhuanlan.zhihu.com/p/330300133" target="_blank" rel="noopener">队头阻塞</a></h2><p>HTTP2.0无法解决TCP队首阻塞问题。因为TCP使用滑动窗口机制来保证数据传输的可靠性，所以当出现一个数据包丢失时，当前连接就需要等待丢失的数据包重新传输，会将所有的HTTP请求都阻塞掉。HTTP3.0通过是使用QUIC协议替换TCP协议来解决该问题。QUIC底层使用UDP协议实现数据传输，所以该数据包看你被运营商丢弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/duoani/HTTP-RFCs.zh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络编程模型</title>
    <link href="http://yoursite.com/2019/10/10/%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/10/基础之网络编程模型/</id>
    <published>2019-10-10T02:22:43.000Z</published>
    <updated>2021-07-09T13:15:37.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程驱动和事件驱动"><a href="#线程驱动和事件驱动" class="headerlink" title="线程驱动和事件驱动"></a>线程驱动和事件驱动</h3><ul><li>线程驱动：当收到一个请求的时候，将会为该请求开一个新的线程来处理请求。一般存在一个线程池，线程池中有空闲的线程，会从线程池中拿取线程来进行处理，如果线程池中没有空闲的线程，新来的请求将会进入队列排队，直到线程池中空闲线程。</li><li>事件驱动：当进来一个新的请求的时，请求将会被压入队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。<b>对于事件驱动编程来说，如果某个时间的回调函数是计算密集型，或者是阻塞I/O,那么这个回调函数将会阻塞后面所有事件回调函数的执行。</b><a id="more"></a></li></ul><h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a>五种I/O模型</h2><p>对于Unix的一次I/O访问（以read为例），数据会先被拷贝到操作系统的缓冲区中，然后才会从操作系统的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生的时候，会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)。</li><li>将数据从内核中拷贝到进程中（Copying the data from the kernel to the process）。</li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>文件描述符：是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</li><li>缓存I/O：又称标准I/O，大多数文件系统中默认I/O都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</li></ul><h3 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h3><p>在Linux中，默认情况下所有的Socket都是阻塞的。当用户进程调用了recvfrom这个系统调用，内核就开始了IO的第一个阶段：准备数据。对于网络IO来说，很多时候数据一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候内核就要等待足够的数据到来。而在用户进程这边，整个进程就会被阻塞（是进程自己选择的阻塞）。当内核的数据准备好了，用户进程才解除阻塞的状态并将数据从内核拷贝到用户内存。</p><blockquote><p><b>阻塞I/O的特点是在I/O执行的两个阶段都被阻塞了。</b></p></blockquote><h3 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h3><p>Linux中也可以设置Socket使其变成非阻塞。即当用户发出read操作时，如果内核中数据还没有准备好，那么它并不会阻塞用户进程，而是立即返回一个错误。从用户进程的角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么用户进程就可以就将数据拷贝到了用户内存。</p><blockquote><p><b>非阻塞I/O虽然在第一阶段不会阻塞，但是用户进程需要不断的主动询问内核数据是否准备好了。</b></p></blockquote><h3 id="I-O复用模型-select、poll、epoll"><a href="#I-O复用模型-select、poll、epoll" class="headerlink" title="I/O复用模型 - select、poll、epoll"></a>I/O复用模型 - select、poll、epoll</h3><p>应用进程调用select函数并阻塞在该系统调用上，而不是阻塞在真正的I/O系统调用上。然后将Socket注册到该函数上，该函数会不断的轮询所负责的所有Socket，当某个Socket有数据到达了，就通知用户进程。然后用户进程调用recvfrom把所读数据报复制到应用进程缓冲区。将数据从内核拷贝到用户进程。</p><blockquote><p><b>I/O复用优势在于单个进程可以处理多个网络连接，但在单个网络连接上并不显得有什么优势，事实上由于使用select需要两个而不是单个系统调用，I/O复用还稍有劣势。</b></p></blockquote><h3 id="信号驱动式I-O模型"><a href="#信号驱动式I-O模型" class="headerlink" title="信号驱动式I/O模型"></a>信号驱动式I/O模型</h3><p>也可以用信号，让内核在描述符就绪时发送SIGIO信号通知用户进程。首先开启套接字的信号驱动式I/O功能并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，用户进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p><blockquote><p><b>模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</b></p></blockquote><h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。</p><blockquote><p><b>异步I/O的特点是在I/O的两个阶段都不会阻塞。</b></p></blockquote><h3 id="一般来说，服务端IO主要有两种情况：来着网络的IO和对文件（设备）的IO。Windows的AIO模型能很好的适用于这两种情况。而Linux针对前者提供了epoll模型，针对后者提供了AIO模型。"><a href="#一般来说，服务端IO主要有两种情况：来着网络的IO和对文件（设备）的IO。Windows的AIO模型能很好的适用于这两种情况。而Linux针对前者提供了epoll模型，针对后者提供了AIO模型。" class="headerlink" title="一般来说，服务端IO主要有两种情况：来着网络的IO和对文件（设备）的IO。Windows的AIO模型能很好的适用于这两种情况。而Linux针对前者提供了epoll模型，针对后者提供了AIO模型。"></a>一般来说，服务端IO主要有两种情况：来着网络的IO和对文件（设备）的IO。Windows的AIO模型能很好的适用于这两种情况。而Linux针对前者提供了epoll模型，针对后者提供了AIO模型。</h3><h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a><a href="https://segmentfault.com/a/1190000003063859?utm_source=Weibo&amp;utm_medium=shareLink&amp;utm_campaign=socialShare&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">IO复用模型</a></h2><h3 id="select、poll、epoll都是IO多路复用的机制的实现。I-O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I-O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I-O则无需自己负责进行读写，异步I-O的实现会负责把数据从内核拷贝到用户空间。"><a href="#select、poll、epoll都是IO多路复用的机制的实现。I-O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I-O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I-O则无需自己负责进行读写，异步I-O的实现会负责把数据从内核拷贝到用户空间。" class="headerlink" title="select、poll、epoll都是IO多路复用的机制的实现。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。"></a>select、poll、epoll都是IO多路复用的机制的实现。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</h3><h3 id="select模式"><a href="#select模式" class="headerlink" title="select模式"></a>select模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>当用户进程调用了select函数，那么整个进程会被阻塞，同时，内核被委托会监视所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</li><li>select函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间），函数返回。select函数只返回就绪的描述符的数量而不能具体到那个描述符，所以需要遍历fd_set，来找到真正就绪的描述符。</li></ol><h3 id="select模式的缺点"><a href="#select模式的缺点" class="headerlink" title="select模式的缺点"></a>select模式的缺点</h3><ol><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，同时每次调用select都需要在内核遍历传递进来的所有fd，增加了系统开销。</li><li>内核和用户进程都需要遍历fd_set来获取就绪的描述符，所以当文件描述符数量过大后性能会下降。</li><li>select支持的文件描述符数量太小了，默认是1024。</li></ol><h3 id="poll和select的区别"><a href="#poll和select的区别" class="headerlink" title="poll和select的区别"></a>poll和select的区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 文件描述发 */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* 实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构体而不是select的fd_set数组结构。同时，pollfd并没有最大数量限制，但是数量过大后性能也是会下降，因为poll函数返回后，也需要需要轮询pollfd来获取就绪的描述符。</p><h3 id="epoll函数介绍"><a href="#epoll函数介绍" class="headerlink" title="epoll函数介绍"></a><a href="https://blog.csdn.net/yusiguyuan/article/details/41287549" target="_blank" rel="noopener">epoll函数介绍</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>epoll_create函数：创建一个epoll_event树的根节点，size用来告诉内核这个epoll可能监听的文件描述符数目，该参数并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。当创建好epoll句柄后，它就会占用一个fd值，在linux下可以通过查看/proc/进程id/fd/查看这个fd，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</li><li><p>epoll_ctl函数：对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create函数的返回值，即句柄数的根节点。</li><li>op：表示op操作，用三个宏来表示，添加EPOLL_CTL_ADD、删除EPOLL_CTL_DEL、修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）。</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="keyword">epoll_data_t</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure></li></ul></li><li><p>epoll_wait函数：等待epfd上的io事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p></li></ol><h3 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h3><p>一个管道收到了1kb的数据，epoll会立即返回，此时读了512字节数据，然后再次调用epoll。这时如果是水平触发的，epoll会立即返回，因为有数据准备好了。如果是边缘触发的不会立即返回，因为此时虽然有数据可读但是已经触发了一次通知，在这次通知到现在还没有新的数据到来，直到有新的数据到来epoll才会返回，此时老的数据和新的数据都可以读取到（当然是需要这次你尽可能的多读取）。</p><h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><p>传统的Linux操作系统的标准I/O接口是基于数据拷贝操作的，即I/O操作会导致数据在操作系统内核地址空间的缓冲区和应用程序地址空间定义的缓冲区之间进行传输。这样做最大的好处是可以减少磁盘I/O的操作，因为如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘I/O操作。但是数据传输过程中的数据拷贝操作却导致了极大的CPU开销，限制了操作系统有效进行数据传输操作的能力。而零拷贝可以避免在用户态(User-space)与内核态(Kernel-space)之间来回拷贝数据。</p><h3 id="缓冲I-O进行数据传输的流程"><a href="#缓冲I-O进行数据传输的流程" class="headerlink" title="缓冲I/O进行数据传输的流程"></a>缓冲I/O进行数据传输的流程</h3><ol><li>当应用程序需要访问某块数据的时候，操作系统内核会先检查这块数据是不是因为前一次对相同文件的访问而已经被存放在操作系统内核地址空间的缓冲区内，如果在内核缓冲区中找不到这块数据，Linux操作系统内核会先将这块数据从磁盘读出来放到操作系统内核的缓冲区里去。如果这个数据读取操作是由DMA完成的，那么在DMA进行数据读取的这一过程中，CPU只是需要进行缓冲区管理，以及创建和处理DMA，除此之外，CPU不需要再做更多的事情。<ul><li>DMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用CPU，即在传输数据的时候，CPU可以干其他的事情，好像是多线程一样。</li></ul></li><li>DMA执行完数据读取操作之后，会通知操作系统做进一步的处理。Linux操作系统会根据read()系统调用指定的应用程序地址空间的地址，把这块数据存放到请求这块数据的应用程序的地址空间中去。</li><li>在接下来的write()系统调用过程中，操作系统需要将数据再一次从用户应用程序地址空间的缓冲区拷贝到与网络堆栈相关的内核缓冲区中去，这个过程也是需要占用CPU的。</li><li>数据拷贝操作结束以后，数据会被打包，然后发送到网络接口卡上去。在数据传输的过程中，应用程序可以先返回进而执行其他的操作。</li></ol><h3 id="Linux中的零拷贝技术"><a href="#Linux中的零拷贝技术" class="headerlink" title="Linux中的零拷贝技术"></a>Linux中的零拷贝技术</h3><ul><li>直接I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输：这类零拷贝技术针对的是<b>操作系统内核并不需要对数据进行直接处理</b>的情况，数据可以在应用程序地址空间的缓冲区和磁盘之间直接进行传输，完全不需要Linux操作系统内核提供的页缓存的支持。</li><li><b>应用程序在数据进行传输的过程中不需要对数据进行访问</b>时将数据从Linux的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。Linux中提供类似的系统调用主要有mmap()、sendfile()以及splice()。</li><li>如果操作系统内核和应用程序都需要堆数据进行处理时需要延续了传统的通信方式，但是对页缓存和用户进程的缓冲区之间的传输过程进行优化。在Linux中，该方法主要利用了写时复制技术。</li></ul><h3 id="Netty中的零拷贝"><a href="#Netty中的零拷贝" class="headerlink" title="Netty中的零拷贝"></a><a href="https://segmentfault.com/a/1190000007560884" target="_blank" rel="noopener">Netty中的零拷贝</a></h3><p>Netty的零拷贝完全是在用户态(Java层面)的，它的零拷贝的更多的是偏向于优化数据操作这样的概念。</p><ul><li>Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。</li><li>通过wrap操作，我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象，进而避免了拷贝操作。</li><li>ByteBuf支持slice操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</li><li>通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li></ul><h3 id="sendfile-函数"><a href="#sendfile-函数" class="headerlink" title="sendfile()函数"></a>sendfile()函数</h3><ol><li>sendfile()系统调用利用DMA引擎将文件中的数据拷贝到操作系统内核缓冲区中后数据被拷贝到与socket相关的内核缓冲区中去。然后网卡的DMA引擎将数据从内核socket缓冲区中拷贝到协议引擎中去。该操作在进行数据传输仍然还需要一次多余的数据拷贝操作。</li><li>在Linux2.4中将文件中的数据拷贝到操作系统内核缓冲区中后直接将带有文件位置和长度信息的缓冲区描述符添加到socket缓冲区中去，此过程不需要将数据从操作系统内核缓冲区拷贝到socket缓冲区中，网卡的DMA引擎会将数据直接从内核缓冲区拷贝到协议引擎中去。</li></ol><p>相关参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/index.html" target="_blank" rel="noopener">Linux中的零拷贝技术1</a> | <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/index.html" target="_blank" rel="noopener">Linux中的零拷贝技术2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程驱动和事件驱动&quot;&gt;&lt;a href=&quot;#线程驱动和事件驱动&quot; class=&quot;headerlink&quot; title=&quot;线程驱动和事件驱动&quot;&gt;&lt;/a&gt;线程驱动和事件驱动&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程驱动：当收到一个请求的时候，将会为该请求开一个新的线程来处理请求。一般存在一个线程池，线程池中有空闲的线程，会从线程池中拿取线程来进行处理，如果线程池中没有空闲的线程，新来的请求将会进入队列排队，直到线程池中空闲线程。&lt;/li&gt;
&lt;li&gt;事件驱动：当进来一个新的请求的时，请求将会被压入队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。&lt;b&gt;对于事件驱动编程来说，如果某个时间的回调函数是计算密集型，或者是阻塞I/O,那么这个回调函数将会阻塞后面所有事件回调函数的执行。&lt;/b&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一些工具类</title>
    <link href="http://yoursite.com/2019/09/23/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/09/23/Java基础之一些工具类/</id>
    <published>2019-09-23T12:56:21.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul><li>基本方法：加（add(BigDecimal)）、减（subtract(BigDecimal)）、乘（multiply(BigDecimal)）、除（divide(BigDecimal)）。</li><li>除法时需要传入小数点后的位数和取值方式。<ul><li>RoundingMode.CEILING：向正无限大方向舍入的舍入模式。</li><li>RoundingMode.FLOOR：向负无限大方向舍入的舍入模式。</li><li>RoundingMode.DOWN：向零方向舍入的舍入模式。</li><li>RoundingMode.UP：远离零方向舍入的舍入模式。</li><li>RoundingMode.HALF_DOWN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。</li><li>RoundingMode.HALF_UP：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。</li><li>RoundingMode.HALF_EVEN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。</li><li>RoundingMode.UNNECESSARY用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。</li></ul></li><li>stripTrailingZeros()方法可以去除尾部的0，然后可以用scale()获取小数点的位数。</li><li>toString()方法可能是科学计数法所以可以使用toPlainString()方法转换为字符串。</li><li>Double转BigDecimal使用BigDecimal.valueOf(Double)而不是new BigDecimal(Double)否则可能会丢失精度。<a id="more"></a></li></ul><h3 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h3><pre><code>java.sql.Datejava.util.Datejava.util.Calendarjava.time.    LocalDate       只包含日期，比如：2018-09-24    LocalTime       只包含时间，比如：10:32:10    LocalDateTime   包含日期和时间，比如：2018-09-24 10:32:10    时间和字符串之间的相互转换：    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);    LocalDateTime now = LocalDateTime.now();    String nowText = now.format(formatter);    LocalDateTime datetime = LocalDateTime.parse(nowText, formatter);java.util.concurrent.TimeUnitorg.apache.commons.lang3.time.    DateUtils    DateFormatUtils</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;BigDecimal&quot;&gt;&lt;a href=&quot;#BigDecimal&quot; class=&quot;headerlink&quot; title=&quot;BigDecimal&quot;&gt;&lt;/a&gt;BigDecimal&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本方法：加（add(BigDecimal)）、减（subtract(BigDecimal)）、乘（multiply(BigDecimal)）、除（divide(BigDecimal)）。&lt;/li&gt;
&lt;li&gt;除法时需要传入小数点后的位数和取值方式。&lt;ul&gt;
&lt;li&gt;RoundingMode.CEILING：向正无限大方向舍入的舍入模式。&lt;/li&gt;
&lt;li&gt;RoundingMode.FLOOR：向负无限大方向舍入的舍入模式。&lt;/li&gt;
&lt;li&gt;RoundingMode.DOWN：向零方向舍入的舍入模式。&lt;/li&gt;
&lt;li&gt;RoundingMode.UP：远离零方向舍入的舍入模式。&lt;/li&gt;
&lt;li&gt;RoundingMode.HALF_DOWN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。&lt;/li&gt;
&lt;li&gt;RoundingMode.HALF_UP：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。&lt;/li&gt;
&lt;li&gt;RoundingMode.HALF_EVEN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。&lt;/li&gt;
&lt;li&gt;RoundingMode.UNNECESSARY用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;stripTrailingZeros()方法可以去除尾部的0，然后可以用scale()获取小数点的位数。&lt;/li&gt;
&lt;li&gt;toString()方法可能是科学计数法所以可以使用toPlainString()方法转换为字符串。&lt;/li&gt;
&lt;li&gt;Double转BigDecimal使用BigDecimal.valueOf(Double)而不是new BigDecimal(Double)否则可能会丢失精度。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之适配器模式</title>
    <link href="http://yoursite.com/2019/07/15/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/07/15/Java设计模式之适配器模式/</id>
    <published>2019-07-15T11:19:54.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<p>统中有一套完整的类结构，而我们需要利用其中摸某一个类的功能（即方法），但是我们的客户端只认识另一个和这个类结构不相关的接口，这时候就可以使用适配器模式将这个现有的类与我们的目标接口进行适配，最终获得一个符合需要的接口并包含复用的类的功能的类。本来是火鸡却实现鸭子接口，当你客户需要一个鸭子的时候，就可以假装成鸭子。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Duck duck = <span class="keyword">new</span> TurkeyAdapter(<span class="keyword">new</span> Turkey() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"咯咯叫！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"火鸡飞不远！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        duck.fly();</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统中有一套完整的类结构，而我们需要利用其中摸某一个类的功能（即方法），但是我们的客户端只认识另一个和这个类结构不相关的接口，这时候就可以使用适配器模式将这个现有的类与我们的目标接口进行适配，最终获得一个符合需要的接口并包含复用的类的功能的类。本来是火鸡却实现鸭子接口，当你客户需要一个鸭子的时候，就可以假装成鸭子。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之观察者模式</title>
    <link href="http://yoursite.com/2019/07/15/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/07/15/Java设计模式之观察者模式/</id>
    <published>2019-07-15T11:16:15.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（又称发布-订阅模式），即一个目标物体管理所有依赖于他的观察者物体，并且在它本身状态改变时，它的所有依赖者都会收到通知并自动更新。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者1观察到"</span> + o.getClass().getSimpleName() + <span class="string">"发生变化"</span>);</span><br><span class="line">        System.out.println(<span class="string">"观察者1做出相应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"观察者1观察到"</span> + o.getClass().getSimpleName() + <span class="string">"发生变化"</span>);</span><br><span class="line">        System.out.println(<span class="string">"观察者1做出相应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fengbo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是被观察者，我已经发生变化了"</span>);</span><br><span class="line">        <span class="comment">// 通知观察自己的所有观察者</span></span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Observable observable = <span class="keyword">new</span> Observable();</span><br><span class="line">        observable.addObserver(<span class="keyword">new</span> ConcreteObserver1());</span><br><span class="line">        observable.addObserver(<span class="keyword">new</span> ConcreteObserver2());</span><br><span class="line">        observable.changed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者模式（又称发布-订阅模式），即一个目标物体管理所有依赖于他的观察者物体，并且在它本身状态改变时，它的所有依赖者都会收到通知并自动更新。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之代理模式</title>
    <link href="http://yoursite.com/2019/07/15/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/07/15/Java设计模式之代理模式/</id>
    <published>2019-07-15T11:09:38.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式一般分为静态代理和动态代理。两种代理从虚拟机加载类的角度来讲，本质上都是一样的，都是在原有类的基础上加入一些其他的逻辑，产生一个新的与原有类接口相同确行为不同的类型。<br><a id="more"></a></p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 被代理的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被装饰的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fengbo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceImpl</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----Real Method-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        source = <span class="keyword">new</span> SourceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----Proxy Before------"</span>);</span><br><span class="line">        source.method();</span><br><span class="line">        System.out.println(<span class="string">"----Proxy After-------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------proxy: "</span> + proxy.getClass() + <span class="string">", method: "</span> + method);</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                System.out.println(<span class="string">" "</span> + arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxy, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式一般分为静态代理和动态代理。两种代理从虚拟机加载类的角度来讲，本质上都是一样的，都是在原有类的基础上加入一些其他的逻辑，产生一个新的与原有类接口相同确行为不同的类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之策略模式</title>
    <link href="http://yoursite.com/2019/07/15/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/07/15/Java设计模式之策略模式/</id>
    <published>2019-07-15T11:04:33.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式定义和封装了一系列的算法，并将每一个算法封装起来，使他们可以相互替换。策略模式让算法独立于使用它的用户而存在。Java8对策略模式进行了很好的封装。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 飞行方式 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火箭飞行策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fengbo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyWithRocket</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我可以靠着火箭飞！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翅膀飞行策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fengbo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我可以靠着翅膀飞！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 行为参数化版策略模式，参考Java8实战，第二章通过行为参数化传递代码</span></span><br><span class="line"><span class="comment">     * 可以使用java.util.function包里的接口替换FlyBehavior接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flyBehavior 具体的飞行策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">(String str, Consumer&lt;String&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyBehavior flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">        duck.setFlyBehavior(flyBehavior);</span><br><span class="line">        duck.performFly();</span><br><span class="line">        duck.setFlyBehavior(<span class="keyword">new</span> FlyWithRocket());</span><br><span class="line">        duck.performFly();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda简写策略模式</span></span><br><span class="line">        duck.performFly(() -&gt; System.out.println(<span class="string">"我可以靠着风筝飞"</span>));</span><br><span class="line">        duck.performFly(<span class="string">"我可以靠着智商飞"</span>, System.out::println);</span><br><span class="line">        <span class="comment">// 等同于下面</span></span><br><span class="line"><span class="comment">//        duck.performFly("我可以靠着智商飞", (str) -&gt; System.out.println(str));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式定义和封装了一系列的算法，并将每一个算法封装起来，使他们可以相互替换。策略模式让算法独立于使用它的用户而存在。Java8对策略模式进行了很好的封装。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之模板方法模式</title>
    <link href="http://yoursite.com/2019/07/15/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/07/15/Java设计模式之模板方法模式/</id>
    <published>2019-07-15T10:59:42.000Z</published>
    <updated>2021-07-03T01:30:27.668Z</updated>
    
    <content type="html"><![CDATA[<p>模板方法模式会在父类的一个方法中定义一个算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结果的情况下，重新定义算法中的某些步骤。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPageBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">buildHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先加入doctype,因为都是html页面,所以我们父类不需要推迟给子类实现,直接在父类实现</span></span><br><span class="line">        stringBuffer.append(<span class="string">"&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;"</span>);</span><br><span class="line">        <span class="comment">// 页面下面就是成对的一个HTML标签，我们也在父类加入,不需要给子类实现</span></span><br><span class="line">        stringBuffer.append(<span class="string">"&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;"</span>);</span><br><span class="line">        <span class="comment">// 下面就应该是head标签里的内容了,这个我们父类做不了主了,推迟到子类实现,所以我们定义一个抽象方法,让子类必须实现</span></span><br><span class="line">        appendHead(stringBuffer);</span><br><span class="line">        <span class="comment">// 下面是body的内容了，我们父类依然无法做主，仍然推迟到子类实现</span></span><br><span class="line">        appendBody(stringBuffer);</span><br><span class="line">        <span class="comment">// html标签的关闭</span></span><br><span class="line">        stringBuffer.append(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个模板方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuffer 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(StringBuffer stringBuffer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二个模板方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuffer 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">appendBody</span><span class="params">(StringBuffer stringBuffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPageBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractPageBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(StringBuffer stringBuffer)</span> </span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">"&lt;head&gt;&lt;title&gt;你好&lt;/title&gt;&lt;/head&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">appendBody</span><span class="params">(StringBuffer stringBuffer)</span> </span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">"&lt;body&gt;&lt;h1&gt;你好,世界！&lt;/h1&gt;&lt;/body&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractPageBuilder pageBuilder = <span class="keyword">new</span> MyPageBuilder();</span><br><span class="line">        System.out.println(pageBuilder.buildHtml());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模板方法模式会在父类的一个方法中定义一个算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结果的情况下，重新定义算法中的某些步骤。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
